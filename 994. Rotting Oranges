class Solution {
public:
    bool valid(pair<int,int>neib,int m, int n){
        if(neib.first<0||neib.first>=m||neib.second<0||neib.second>=n){
            return false;
        }
        return true;
        
    }
    
    int orangesRotting(vector<vector<int>>& grid) {
        
        
       int m=grid.size();
       int n=grid[0].size();
        queue<pair<int,int>>Q;
        int fresh=0;
        
        for(int x=0;x<m;x++){
            for(int y=0;y<n;y++){
                if(grid[x][y]==2){  
                    Q.push({x,y});
                    
                }   
                if(grid[x][y]==1){
                    fresh++;
                }
            }        
        }
        const int dx[]={0,0,1,-1};
        const int dy[]={1,-1,0,0};
        
        int minute=0;
       
        
       //&&fresh is really important here, as if initially there are multiple 2s, they are starting at the same second, but we only pop out one of them eahc time
        
        while(!Q.empty()&&fresh){
          int size=Q.size();
         while(size--){ //short hand of size-1 !=0, but this is a post-decrement so the last value of size=-1
            pair<int,int>node=Q.front();
            Q.pop();
            
            
            for(int i=0;i<4;i++){                
                pair<int,int>neib={node.first+dx[i],node.second+dy[i]};
                
                if(valid(neib,m,n)&&grid[neib.first][neib.second]==1){         
                    grid[neib.first][neib.second]=2;
                    Q.push(neib);     
                    fresh--; 
                    
                    }
                
                }
             
             }
            //we only increment time when:there is something in the Q so still 2s to go
            //after each inner while we increment time , bc the 4-directional neighbours are infected in the same minute
            //the reason for keepping track of fresh is to terminate the traversal when all freshs are infected(helps to correct the time as well)
            //bc there is a case of which there is still some 2s left in the Q, but there are no freshs, we need to stop counting time here
            //also, the innner while loop deals with the number of initial rotten oranges before the traversal starts, making sure the rotting process is simutaneously
            
            minute++;
            }
    
        return fresh? -1:minute;
        
        
        
        
            
        }   
           
        
        
        
            
             
       
        
        
       
        
        
        
        
    };
